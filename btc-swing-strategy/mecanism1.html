<!DOCTYPE html>
<html lang="ro">
<head>
  <meta charset="UTF-8" />
  <title>Mecanism Coeziv BTC – Context de piață</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #020617;
      --bg-card: rgba(15, 23, 42, 0.98);
      --bg-chip: rgba(15, 23, 42, 0.9);
      --border-soft: #1f2937;
      --text-main: #e5e7eb;
      --text-muted: #9ca3af;
      --text-soft: #6b7280;
      --accent-long: #22c55e;
      --accent-short: #f97373;
      --accent-neutral: #6366f1;
      --band-bg: linear-gradient(90deg, #22c55e 0%, #e5e7eb 50%, #f97373 100%);
      --band-track: rgba(15, 23, 42, 0.9);
      --band-border: #1f2937;
      --bg-btc: rgba(17, 24, 39, 0.95);
      --bg-model: rgba(15, 23, 42, 0.9);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Segoe UI", sans-serif;
      background:
        radial-gradient(circle at top left, #0f172a 0, #020617 38%, #020617 100%),
        radial-gradient(circle at bottom right, #111827 0, #020617 45%, #020617 100%);
      color: var(--text-main);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .shell {
      width: 100%;
      max-width: 960px;
      padding: 16px;
    }

    .card {
      border-radius: 24px;
      border: 1px solid var(--border-soft);
      background: var(--bg-card);
      padding: 18px 20px 18px;
      box-shadow: 0 26px 60px rgba(15, 23, 42, 0.9);
    }

    .layout {
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 1.2fr);
      gap: 20px;
      align-items: stretch;
    }

    @media (max-width: 820px) {
      .layout {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .label-main {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--text-soft);
    }

    .chip-small {
      font-size: 10px;
      color: var(--text-soft);
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid var(--border-soft);
      background: var(--bg-chip);
    }

    /* STÂNGA – PREȚURI + BARĂ */
    .prices-block {
      margin-top: 6px;
      margin-bottom: 14px;
    }

    .prices-row {
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 0.9fr);
      gap: 10px;
    }

    .price-box {
      border-radius: 16px;
      border: 1px solid var(--border-soft);
      padding: 10px 12px;
    }

    .price-box.btc {
      background: var(--bg-btc);
    }

    .price-box.model {
      background: var(--bg-model);
    }

    .price-label {
      font-size: 11px;
      color: var(--text-soft);
      margin-bottom: 2px;
    }

    .price-value-btc {
      font-size: 24px;
      font-weight: 600;
      color: var(--text-main);
    }

    .price-value-model {
      font-size: 14px;
      font-weight: 500;
      color: var(--text-muted);
    }

    .price-sub {
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 2px;
    }

    .band-block {
      margin-top: 10px;
    }

    .band-label {
      font-size: 11px;
      color: var(--text-soft);
      margin-bottom: 4px;
    }

    .band-track {
      position: relative;
      width: 100%;
      height: 12px;
      border-radius: 999px;
      border: 1px solid var(--band-border);
      background: var(--band-bg);
      overflow: hidden;
    }

    .band-center-line {
      position: absolute;
      left: 50%;
      top: 0;
      bottom: 0;
      width: 1px;
      background: rgba(15, 23, 42, 0.7);
      opacity: 0.7;
    }

    .band-marker {
      position: absolute;
      top: -4px;
      width: 0;
      height: 0;
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
      border-bottom: 8px solid #e5e7eb;
      filter: drop-shadow(0 0 4px rgba(0,0,0,0.7));
      transition: left 0.3s ease-out;
    }

    .band-legend {
      margin-top: 4px;
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      color: var(--text-soft);
    }

    .diff-text-main {
      margin-top: 6px;
      font-size: 13px;
      font-weight: 500;
      color: var(--text-main);
    }

    .diff-text-main.positive {
      color: var(--accent-short);
    }

    .diff-text-main.negative {
      color: var(--accent-long);
    }

    .diff-text-sub {
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 2px;
    }

    /* DREAPTA – CONTEXT */
    .status-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .signal-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid var(--border-soft);
      background: var(--bg-chip);
      font-size: 11px;
      color: var(--text-muted);
    }

    .signal-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: var(--accent-neutral);
    }

    .signal-chip.long .signal-dot {
      background: var(--accent-long);
    }

    .signal-chip.short .signal-dot {
      background: var(--accent-short);
    }

    .headline {
      font-size: 16px;
      font-weight: 600;
      color: var(--text-main);
      margin-bottom: 6px;
    }

    .headline.long {
      color: var(--accent-long);
    }

    .headline.short {
      color: var(--accent-short);
    }

    .context-text {
      font-size: 13px;
      color: var(--text-main);
      line-height: 1.5;
      margin-bottom: 8px;
    }

    .meta-text {
      font-size: 11px;
      color: var(--text-muted);
    }

    .error-text {
      font-size: 11px;
      color: var(--accent-short);
      margin-top: 4px;
    }

    .tags-grid {
      margin-top: 12px;
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
    }

    .tag-box {
      border-radius: 14px;
      border: 1px solid var(--border-soft);
      background: rgba(15, 23, 42, 0.92);
      padding: 8px 10px;
    }

    .tag-label {
      font-size: 11px;
      color: var(--text-soft);
      margin-bottom: 2px;
    }

    .tag-main {
      font-size: 12px;
      font-weight: 500;
      color: var(--text-main);
    }

    .tag-sub {
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 1px;
    }
  </style>
</head>
<body>
<div class="shell">
  <div class="card">
    <div class="card-header">
      <div class="label-main">BTC · MECANISM COEZIV</div>
      <div class="chip-small">Snapshot de context, nu semnal de intrare</div>
    </div>

    <div class="layout">
      <!-- STÂNGA: PREȚURI + BARĂ -->
      <section>
        <div class="prices-block">
          <div class="prices-row">
            <div class="price-box btc">
              <div class="price-label">BTC în acest snapshot</div>
              <div class="price-value-btc" id="price-btc">–</div>
              <div class="price-sub">
                Valoarea BTC exact în momentul în care a fost generat snapshotul.
              </div>
            </div>
            <div class="price-box model">
              <div class="price-label">Preț mecanism (același snapshot)</div>
              <div class="price-value-model" id="price-model">–</div>
              <div class="price-sub">
                Nivelul estimat de mecanism pentru BTC în acest context.
              </div>
            </div>
          </div>
        </div>

        <div class="band-block">
          <div class="band-label">Unde stă BTC față de mecanism</div>
          <div class="band-track" id="band-track">
            <div class="band-center-line"></div>
            <div class="band-marker" id="band-marker" style="left:50%;"></div>
          </div>
          <div class="band-legend">
            <span>sub model</span>
            <span>în zona modelului</span>
            <span>peste model</span>
          </div>

          <div class="diff-text-main" id="diff-main">
            Nu putem evalua diferența față de mecanism.
          </div>
          <div class="diff-text-sub" id="diff-sub"></div>
        </div>
      </section>

      <!-- DREAPTA: CONTEXT + FLUX / LICHIDITATE -->
      <section>
        <div class="status-row">
          <div class="headline" id="headline">
            Se încarcă contextul mecanic...
          </div>
          <div>
            <span id="signal-chip" class="signal-chip">
              <span class="signal-dot"></span>
              <span id="signal-label">Context neutru</span>
            </span>
          </div>
        </div>

        <p class="context-text" id="context-message">
          Așteptăm mesajul coeziv generat de mecanism.
        </p>

        <div class="meta-text" id="context-meta">
          Context construit pe baza poziționării BTC în jurul prețului mecanismului, a fluxului și a lichidității.
        </div>

        <div class="error-text" id="context-error"></div>

        <div class="tags-grid">
          <div class="tag-box">
            <div class="tag-label">Flux de piață</div>
            <div class="tag-main" id="flow-main">n/a</div>
            <div class="tag-sub" id="flow-sub">
              Direcția și intensitatea ultimei mișcări de preț.
            </div>
          </div>
          <div class="tag-box">
            <div class="tag-label">Lichiditate</div>
            <div class="tag-main" id="liquidity-main">n/a</div>
            <div class="tag-sub" id="liquidity-sub">
              Cât de „densă” sau „subțire” este piața în acest context.
            </div>
          </div>
        </div>
      </section>
    </div>
  </div>
</div>

<script>
  const STATE_URL = "coeziv_state.json";

  const USD_FMT = new Intl.NumberFormat("en-US", {
    minimumFractionDigits: 0,
    maximumFractionDigits: 0
  });
  const PCT_FMT = new Intl.NumberFormat("en-US", {
    minimumFractionDigits: 1,
    maximumFractionDigits: 1
  });

  function mapSignal(signal) {
    const s = (signal || "").toLowerCase();
    if (s === "long") {
      return {
        label: "Presiune de creștere",
        headline: "Context: presiune de creștere",
        className: "long"
      };
    }
    if (s === "short") {
      return {
        label: "Risc de scădere",
        headline: "Context: risc de scădere",
        className: "short"
      };
    }
    return {
      label: "Context neutru",
      headline: "Context: neutru",
      className: ""
    };
  }

  function buildDiff(modelPrice, btcPrice) {
    if (!Number.isFinite(modelPrice) || !Number.isFinite(btcPrice) || modelPrice <= 0) {
      return {
        main: "Nu putem evalua diferența față de mecanism.",
        sub: "",
        pct: null,
        className: ""
      };
    }
    const diff = btcPrice - modelPrice;
    const pct = diff / modelPrice;
    const absDiff = Math.abs(diff);
    const absPct = Math.abs(pct) * 100;

    const pctStr = PCT_FMT.format(absPct) + "%";
    const usdStr = USD_FMT.format(absDiff) + " USD";

    if (Math.abs(pct) < 0.005) {
      return {
        main: "BTC este foarte aproape de nivelul estimat de mecanism.",
        sub: `Abatere ≈ ${usdStr} (${pctStr}).`,
        pct,
        className: ""
      };
    } else if (pct > 0) {
      return {
        main: "BTC este peste nivelul estimat de mecanism.",
        sub: `Aproximativ +${usdStr} (+${pctStr}) peste model.`,
        pct,
        className: "positive"
      };
    } else {
      return {
        main: "BTC este sub nivelul estimat de mecanism.",
        sub: `Aproximativ -${usdStr} (-${pctStr}) sub model.`,
        pct,
        className: "negative"
      };
    }
  }

  function positionMarker(pct, trackEl, markerEl) {
    if (!trackEl || !markerEl) return;
    // pct este diferența relativă (ex: 0.02 = +2%)
    if (pct == null || !Number.isFinite(pct)) {
      markerEl.style.left = "50%";
      return;
    }
    // clamp ±4% în bandă (ce e peste 4% rămâne la margine)
    const maxPct = 0.04;
    const r = Math.max(-maxPct, Math.min(maxPct, pct));
    const offset = (r / maxPct) * 40; // ±40% din lățime
    const pos = 50 + offset;
    markerEl.style.left = pos + "%";
  }

  function buildFlowText(bias, strength) {
    if (!bias) return { main: "n/a", sub: "Nu există suficiente date pentru a evalua fluxul de piață." };
    let dir;
    if (bias === "pozitiv") dir = "presiune de cumpărare";
    else if (bias === "negativ") dir = "presiune de vânzare";
    else if (bias === "neutru") dir = "flux relativ echilibrat";
    else dir = bias;

    let main = dir;
    if (strength) main += ` (${strength})`;

    let sub = "Direcția și intensitatea ultimei mișcări de preț.";
    if (bias === "negativ" && strength === "puternic") {
      sub = "Vânzare puternică recentă; contextul poate fi de extenuare sau de continuare, în funcție de lichiditate.";
    } else if (bias === "pozitiv" && strength === "puternic") {
      sub = "Cumpărare puternică recentă; poate susține continuarea unui raliu sau o corecție pe termen scurt.";
    }

    return { main, sub };
  }

  function buildLiquidityText(regime, strength) {
    if (!regime) return { main: "n/a", sub: "Nu există suficiente date pentru a evalua lichiditatea." };

    let reg;
    if (regime === "ridicată") reg = "ridicată";
    else if (regime === "moderată" || regime === "normală") reg = "moderată";
    else if (regime === "scăzută") reg = "scăzută";
    else reg = regime;

    let main = reg;
    if (strength) main += ` (${strength})`;

    let sub = "Nivel general al ordelor și al volumului în piață.";
    if (regime === "scăzută") {
      sub = "Piața este mai „subțire”; mișcările pot fi mai bruște și mai sensibile la flux.";
    } else if (regime === "ridicată") {
      sub = "Piața este mai densă; mișcările tind să fie mai greu de deplasat de ordine izolate.";
    }

    return { main, sub };
  }

  async function loadState() {
    const priceBtcEl = document.getElementById("price-btc");
    const priceModelEl = document.getElementById("price-model");
    const diffMainEl = document.getElementById("diff-main");
    const diffSubEl = document.getElementById("diff-sub");
    const bandTrackEl = document.getElementById("band-track");
    const bandMarkerEl = document.getElementById("band-marker");

    const signalChip = document.getElementById("signal-chip");
    const signalLabelEl = document.getElementById("signal-label");
    const headlineEl = document.getElementById("headline");
    const messageEl = document.getElementById("context-message");
    const metaEl = document.getElementById("context-meta");
    const errorEl = document.getElementById("context-error");

    const flowMainEl = document.getElementById("flow-main");
    const flowSubEl = document.getElementById("flow-sub");
    const liqMainEl = document.getElementById("liquidity-main");
    const liqSubEl = document.getElementById("liquidity-sub");

    try {
      if (errorEl) errorEl.textContent = "";

      const res = await fetch(STATE_URL + "?t=" + Date.now(), {
        cache: "no-store"
      });
      if (!res.ok) throw new Error("HTTP " + res.status);
      const state = await res.json();

      const modelPrice = state.model_price_usd;
      const btcPrice = typeof state.price_usd === "number" ? state.price_usd : state.spot;
      const signal = state.signal;
      const message = state.message;

      const flowBias = state.flow_bias;
      const flowStrength = state.flow_strength;
      const liqRegime = state.liquidity_regime;
      const liqStrength = state.liquidity_strength;

      const prob = state.signal_probability;
      const horizonHours = state.signal_prob_horizon_hours || 24;
      const drift = state.signal_expected_drift;

      // Prețuri (snapshot)
      if (priceBtcEl) {
        if (Number.isFinite(btcPrice)) {
          priceBtcEl.textContent = USD_FMT.format(btcPrice) + " USD";
        } else {
          priceBtcEl.textContent = "–";
        }
      }
      if (priceModelEl) {
        if (Number.isFinite(modelPrice)) {
          priceModelEl.textContent = USD_FMT.format(modelPrice) + " USD";
        } else {
          priceModelEl.textContent = "–";
        }
      }

      // Diferență + marker pe bandă
      const diffInfo = buildDiff(modelPrice, btcPrice);
      if (diffMainEl) {
        diffMainEl.textContent = diffInfo.main;
        diffMainEl.className = "diff-text-main " + diffInfo.className;
      }
      if (diffSubEl) {
        diffSubEl.textContent = diffInfo.sub;
      }
      positionMarker(diffInfo.pct, bandTrackEl, bandMarkerEl);

      // Signal -> headline + chip
      const sigInfo = mapSignal(signal);
      if (signalLabelEl) signalLabelEl.textContent = sigInfo.label;
      if (headlineEl) {
        headlineEl.textContent = sigInfo.headline;
        headlineEl.className = "headline " + sigInfo.className;
      }
      if (signalChip) {
        signalChip.className = "signal-chip " + sigInfo.className;
      }

      // Mesaj coeziv
      if (messageEl) {
        messageEl.textContent =
          message ||
          "Nu există un mesaj coeziv explicit pentru acest moment. Mecanismul este în modul de observație.";
      }

      // Meta (fără preț de producție, fără istoric explicit)
      if (metaEl) {
        if (typeof prob === "number" && Number.isFinite(prob)) {
          const p = PCT_FMT.format(prob * 100);
          metaEl.innerHTML =
            `Context construit pe baza poziționării BTC față de mecanism, a fluxului și a lichidității, ` +
            `ținând cont de distribuția istorică a contextelor similare (≈ ${p}% frecvență pentru acest tip de scenariu pe ~${horizonHours}h).`;
        } else {
          metaEl.textContent =
            "Context construit pe baza poziționării BTC față de mecanism, a fluxului și a lichidității, raportate la distribuția istorică a contextelor similare.";
        }
      }

      // Flux
      const flowInfo = buildFlowText(flowBias, flowStrength);
      if (flowMainEl) flowMainEl.textContent = flowInfo.main;
      if (flowSubEl) flowSubEl.textContent = flowInfo.sub;

      // Lichiditate
      const liqInfo = buildLiquidityText(liqRegime, liqStrength);
      if (liqMainEl) liqMainEl.textContent = liqInfo.main;
      if (liqSubEl) liqSubEl.textContent = liqInfo.sub;

    } catch (err) {
      console.error(err);
      if (errorEl) {
        errorEl.textContent =
          "Nu am putut încărca contextul mecanismului. Verifică coeziv_state.json sau workflow-ul de backend.";
      }
    }
  }

  // încărcare inițială + refresh periodic (snapshots noi de la backend)
  loadState().catch(console.error);
  setInterval(() => {
    loadState().catch(console.error);
  }, 60000);
</script>
</body>
</html>
