<!DOCTYPE html>
<html lang="ro">
<head>
  <meta charset="UTF-8" />
  <title>Coeziv BTC Market Context — Daily Snapshot</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #020617;
      --bg-card: rgba(15, 23, 42, 0.98);
      --bg-chip: rgba(15, 23, 42, 0.9);
      --border-soft: #1f2937;
      --text-main: #e5e7eb;
      --text-muted: #9ca3af;
      --text-soft: #6b7280;
      --accent-long: #22c55e;
      --accent-short: #f97373;
      --accent-neutral: #6366f1;
      --band-bg: linear-gradient(90deg, #22c55e 0%, #e5e7eb 50%, #f97373 100%);
      --band-track: rgba(15, 23, 42, 0.9);
      --band-border: #1f2937;
      --bg-btc: rgba(17, 24, 39, 0.95);
      --bg-model: rgba(15, 23, 42, 0.9);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Segoe UI", sans-serif;
      background:
        radial-gradient(circle at top left, #0f172a 0, #020617 38%, #020617 100%),
        radial-gradient(circle at bottom right, #111827 0, #020617 45%, #020617 100%);
      color: var(--text-main);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .shell {
      width: 100%;
      max-width: 960px;
      padding: 16px;
    }

    .card {
      border-radius: 24px;
      border: 1px solid var(--border-soft);
      background: var(--bg-card);
      padding: 18px 20px 14px;
      box-shadow: 0 26px 60px rgba(15, 23, 42, 0.9);
    }

    .layout {
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 1.2fr);
      gap: 20px;
      align-items: stretch;
    }

    @media (max-width: 820px) {
      .layout {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .label-main {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--text-soft);
    }

    .chip-small {
      font-size: 10px;
      color: var(--text-soft);
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid var(--border-soft);
      background: var(--bg-chip);
    }

    /* STÂNGA – PREȚURI + BARĂ */
    .prices-block {
      margin-top: 6px;
      margin-bottom: 14px;
    }

    .prices-row {
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 0.9fr);
      gap: 10px;
    }

    .price-box {
      border-radius: 16px;
      border: 1px solid var(--border-soft);
      padding: 10px 12px;
    }

    .price-box.btc {
      background: var(--bg-btc);
    }

    .price-box.model {
      background: var(--bg-model);
    }

    .price-label {
      font-size: 11px;
      color: var(--text-soft);
      margin-bottom: 2px;
    }

    .price-value-btc {
      font-size: 24px;
      font-weight: 600;
      color: var(--text-main);
    }

    .price-value-model {
      font-size: 14px;
      font-weight: 500;
      color: var(--text-muted);
    }

    .price-sub {
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 2px;
    }

    .price-source {
      font-size: 10px;
      color: var(--text-soft);
      margin-top: 2px;
    }

    .band-block {
      margin-top: 10px;
    }

    .band-label {
      font-size: 11px;
      color: var(--text-soft);
      margin-bottom: 4px;
    }

    .band-track {
      position: relative;
      width: 100%;
      height: 12px;
      border-radius: 999px;
      border: 1px solid var(--band-border);
      background: var(--band-bg);
      overflow: hidden;
    }

    .band-center-line {
      position: absolute;
      left: 50%;
      top: 0;
      bottom: 0;
      width: 1px;
      background: rgba(15, 23, 42, 0.7);
      opacity: 0.7;
    }

    .band-marker {
      position: absolute;
      top: -4px;
      width: 0;
      height: 0;
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
      border-bottom: 8px solid #e5e7eb;
      filter: drop-shadow(0 0 4px rgba(0,0,0,0.7));
      transition: left 0.3s ease-out;
    }

    .band-legend {
      margin-top: 4px;
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      color: var(--text-soft);
    }

    .diff-text-main {
      margin-top: 6px;
      font-size: 13px;
      font-weight: 500;
      color: var(--text-main);
    }

    .diff-text-main.positive {
      color: var(--accent-short);
    }

    .diff-text-main.negative {
      color: var(--accent-long);
    }

    .diff-text-sub {
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 2px;
    }

    /* DREAPTA – CONTEXT */
    .status-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .signal-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid var(--border-soft);
      background: var(--bg-chip);
      font-size: 11px;
      color: var(--text-muted);
    }

    .signal-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: var(--accent-neutral);
    }

    .signal-chip.long .signal-dot {
      background: var(--accent-long);
    }

    .signal-chip.short .signal-dot {
      background: var(--accent-short);
    }

    .headline {
      font-size: 16px;
      font-weight: 600;
      color: var(--text-main);
      margin-bottom: 6px;
    }

    .headline.long {
      color: var(--accent-long);
    }

    .headline.short {
      color: var(--accent-short);
    }

    .context-text {
      font-size: 13px;
      color: var(--text-main);
      line-height: 1.5;
      margin-bottom: 8px;
    }

    .meta-text {
      font-size: 11px;
      color: var(--text-muted);
    }

    .error-text {
      font-size: 11px;
      color: var(--accent-short);
      margin-top: 4px;
    }

    .tags-grid {
      margin-top: 12px;
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
    }

    .tag-box {
      border-radius: 14px;
      border: 1px solid var(--border-soft);
      background: rgba(15, 23, 42, 0.92);
      padding: 8px 10px;
    }

    .tag-label {
      font-size: 11px;
      color: var(--text-soft);
      margin-bottom: 2px;
    }

    .tag-main {
      font-size: 12px;
      font-weight: 500;
      color: var(--text-main);
    }

    .tag-sub {
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 1px;
    }

    /* CARD REGIMURI DE PIAȚĂ */
    .market-regimes-card {
      margin-top: 28px;
      padding: 18px;
      border-radius: 22px;
      border: 1px solid var(--border-soft);
      background: rgba(15, 23, 42, 0.96);
    }

    .market-regimes-title {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 14px;
      color: var(--text-main);
    }

    .market-regimes-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
    }

    .regime-item {
      border-radius: 16px;
      padding: 10px 12px;
      border: 1px solid var(--border-soft);
      background: rgba(2, 6, 23, 0.9);
      transition: border-color 0.18s ease-out, box-shadow 0.18s ease-out, transform 0.18s ease-out, background 0.18s ease-out;
    }

    .regime-title {
      font-size: 12px;
      font-weight: 600;
      margin-bottom: 4px;
    }

    .regime-desc {
      font-size: 11px;
      color: var(--text-muted);
    }

    .regime-note {
      font-size: 11px;
      margin-top: 4px;
      color: #d1d5db;
    }

    /* accente vizuale pe marginea stângă */
    .fragile { border-left: 3px solid #f97373; }
    .bearish { border-left: 3px solid #fb7185; }
    .inert { border-left: 3px solid #64748b; }
    .balanced { border-left: 3px solid #94a3b8; }
    .accumulation { border-left: 3px solid #38bdf8; }
    .expansion { border-left: 3px solid #22c55e; }
    .reversal { border-left: 3px solid #eab308; }

    /* highlight automat pentru regimul curent – mult mai vizibil */
    .regime-active {
      border-color: #ffffff;
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.14), rgba(15, 23, 42, 0.98));
      box-shadow: 0 0 0 1px rgba(248, 250, 252, 0.5), 0 14px 32px rgba(15, 23, 42, 0.95);
      transform: translateY(-2px);
    }

    .disclaimer {
      margin-top: 10px;
      font-size: 10px;
      color: var(--text-soft);
      text-align: left;
    }
  </style>
</head>
<body>
<div class="shell">
  <div class="card">
    <div class="card-header">
      <div class="label-main">COEZIV BTC MARKET CONTEXT — DAILY SNAPSHOT</div>
      <div class="chip-small">Snapshot zilnic de context, nu semnal de intrare</div>
    </div>

    <div class="layout">
      <!-- STÂNGA: PREȚURI + BARĂ -->
      <section>
        <div class="prices-block">
          <div class="prices-row">
            <div class="price-box btc">
              <div class="price-label">Preț de referință BTC (snapshot)</div>
              <div class="price-value-btc" id="price-btc">–</div>
              <div class="price-sub">
                Prețul BTC utilizat de mecanism la momentul generării snapshotului.
              </div>
              <div class="price-source" id="price-source">
                Sursă preț: –
              </div>
            </div>
            <div class="price-box model">
              <div class="price-label">Nivel de referință al mecanismului</div>
              <div class="price-value-model" id="price-model">–</div>
              <div class="price-sub">
                Nivelul estimat de model pentru BTC în contextul acestui snapshot.
              </div>
            </div>
          </div>
        </div>

        <div class="band-block">
          <div class="band-label">Poziționarea BTC față de nivelul modelului</div>
          <div class="band-track" id="band-track">
            <div class="band-center-line"></div>
            <div class="band-marker" id="band-marker" style="left:50%;"></div>
          </div>
          <div class="band-legend">
            <span>sub nivelul modelului</span>
            <span>în zona modelului</span>
            <span>peste nivelul modelului</span>
          </div>

          <div class="diff-text-main" id="diff-main">
            Nu putem evalua poziționarea față de nivelul modelului.
          </div>
          <div class="diff-text-sub" id="diff-sub"></div>
        </div>
      </section>

      <!-- DREAPTA: CONTEXT + FLUX / LICHIDITATE -->
      <section>
        <div class="status-row">
          <div class="headline" id="headline">
            Se încarcă Market Context...
          </div>
          <div>
            <span id="signal-chip" class="signal-chip">
              <span class="signal-dot"></span>
              <span id="signal-label">Market Context: neutru</span>
            </span>
          </div>
        </div>

        <p class="context-text" id="context-message">
          Așteptăm mesajul coeziv generat de mecanism.
        </p>

        <div class="meta-text" id="context-meta">
          Context construit pe baza poziționării BTC față de nivelul modelului, a Flow Regime și a Liquidity Regime, raportate la distribuția istorică a contextelor similare.
        </div>

        <div class="error-text" id="context-error"></div>

        <div class="tags-grid">
          <div class="tag-box">
            <div class="tag-label">Flow Regime</div>
            <div class="tag-main" id="flow-main">n/a</div>
            <div class="tag-sub" id="flow-sub">
              Regimul fluxului de piață în acest snapshot (direcție și intensitate).
            </div>
          </div>
          <div class="tag-box">
            <div class="tag-label">Liquidity Regime</div>
            <div class="tag-main" id="liquidity-main">n/a</div>
            <div class="tag-sub" id="liquidity-sub">
              Regimul de lichiditate — cât de „densă” sau „subțire” este piața în acest context.
            </div>
          </div>
        </div>
      </section>
    </div>

    <!-- CARD REGIMURI DE PIAȚĂ -->
    <div class="market-regimes-card">
      <div class="market-regimes-title">
        Situații de piață recurente (ghid de interpretare)
      </div>

      <div class="market-regimes-grid">

        <div class="regime-item fragile" id="regime-1">
          <div class="regime-title">1️⃣ Fragilitate maximă</div>
          <div class="regime-desc">
            Sub model · Vânzare · Lichiditate scăzută
          </div>
          <div class="regime-note">
            Mișcările sunt amplificate de absența market makerilor. Piața este dezechilibrată temporar.
          </div>
        </div>

        <div class="regime-item bearish" id="regime-2">
          <div class="regime-title">2️⃣ Bearish structural</div>
          <div class="regime-desc">
            Sub model · Vânzare · Lichiditate moderată
          </div>
          <div class="regime-note">
            Vânzarea este absorbită ordonat. Piața acceptă niveluri mai joase.
          </div>
        </div>

        <div class="regime-item inert" id="regime-3">
          <div class="regime-title">3️⃣ Piață inertă</div>
          <div class="regime-desc">
            Sub model · Echilibru · Lichiditate scăzută
          </div>
          <div class="regime-note">
            Nici cumpărători, nici vânzători convingători. Stare de tranziție.
          </div>
        </div>

        <div class="regime-item balanced" id="regime-4">
          <div class="regime-title">4️⃣ Echilibru sănătos</div>
          <div class="regime-desc">
            La model · Echilibru · Lichiditate moderată
          </div>
          <div class="regime-note">
            Piață stabilă, market makerii confortabili, volatilitate redusă.
          </div>
        </div>

        <div class="regime-item accumulation" id="regime-5">
          <div class="regime-title">5️⃣ Accumulare ordonată</div>
          <div class="regime-desc">
            La model · Cumpărare · Lichiditate ridicată
          </div>
          <div class="regime-note">
            Interes real, dar fără grabă. Prețul rămâne ancorat.
          </div>
        </div>

        <div class="regime-item expansion" id="regime-6">
          <div class="regime-title">6️⃣ Expansiune sănătoasă</div>
          <div class="regime-desc">
            Peste model · Cumpărare · Lichiditate ridicată
          </div>
          <div class="regime-note">
            Momentum susținut într-o piață elastică. Mișcare validă.
          </div>
        </div>

        <div class="regime-item fragile" id="regime-7">
          <div class="regime-title">7️⃣ Fragilitate bullish</div>
          <div class="regime-desc">
            Peste model · Cumpărare · Lichiditate scăzută
          </div>
          <div class="regime-note">
            Raliu rapid într-o piață subțire. Risc de retragere bruscă.
          </div>
        </div>

        <div class="regime-item reversal" id="regime-8">
          <div class="regime-title">8️⃣ Tranziție de regim</div>
          <div class="regime-desc">
            Peste model · Vânzare · Lichiditate scăzută
          </div>
          <div class="regime-note">
            Semn de distribuție sau schimbare de comportament al pieței.
          </div>
        </div>

      </div>
    </div>

    <div class="disclaimer">
      <strong>Disclaimer</strong> · Acest dashboard oferă un snapshot zilnic de context de piață, bazat pe modele cantitative și date istorice. Informațiile descriu regimul de piață observat la momentul snapshotului și nu constituie recomandări de investiții sau semnale de tranzacționare.
    </div>
  </div>
</div>

<script>
  const STATE_URL = "coeziv_state.json";

  const USD_FMT = new Intl.NumberFormat("en-US", {
    minimumFractionDigits: 0,
    maximumFractionDigits: 0
  });
  const PCT_FMT = new Intl.NumberFormat("en-US", {
    minimumFractionDigits: 1,
    maximumFractionDigits: 1
  });

  function mapSignal(signal) {
    const s = (signal || "").toLowerCase();
    if (s === "long") {
      return {
        label: "Market Context: bias pozitiv",
        headline: "Market Context: bias pozitiv",
        className: "long"
      };
    }
    if (s === "short") {
      return {
        label: "Market Context: bias negativ",
        headline: "Market Context: bias negativ",
        className: "short"
      };
    }
    return {
      label: "Market Context: neutru",
      headline: "Market Context: neutru",
      className: ""
    };
  }

  function buildDiff(modelPrice, btcPrice) {
    if (!Number.isFinite(modelPrice) || !Number.isFinite(btcPrice) || modelPrice <= 0) {
      return {
        main: "Nu putem evalua poziționarea față de nivelul modelului.",
        sub: "",
        pct: null,
        className: ""
      };
    }
    const diff = btcPrice - modelPrice;
    const pct = diff / modelPrice;
    const absDiff = Math.abs(diff);
    const absPct = Math.abs(pct) * 100;

    const pctStr = PCT_FMT.format(absPct) + "%";
    const usdStr = USD_FMT.format(absDiff) + " USD";

    if (Math.abs(pct) < 0.005) {
      return {
        main: "BTC este foarte aproape de nivelul estimat de model.",
        sub: `Abatere ≈ ${usdStr} (${pctStr}).`,
        pct,
        className: ""
      };
    } else if (pct > 0) {
      return {
        main: "BTC este poziționat peste nivelul estimat de model.",
        sub: `Aproximativ +${usdStr} (+${pctStr}) peste nivelul modelului.`,
        pct,
        className: "positive"
      };
    } else {
      return {
        main: "BTC este poziționat sub nivelul estimat de model.",
        sub: `Aproximativ -${usdStr} (-${pctStr}) sub nivelul modelului.`,
        pct,
        className: "negative"
      };
    }
  }

  function positionMarker(pct, trackEl, markerEl) {
    if (!trackEl || !markerEl) return;
    if (pct == null || !Number.isFinite(pct)) {
      markerEl.style.left = "50%";
      return;
    }
    const maxPct = 0.04;
    const r = Math.max(-maxPct, Math.min(maxPct, pct));
    const offset = (r / maxPct) * 40; // ±40% din lățime
    const pos = 50 + offset;
    markerEl.style.left = pos + "%";
  }

  function buildFlowText(bias, strength) {
    if (!bias) return { main: "n/a", sub: "Nu există suficiente date pentru a evalua Flow Regime." };
    let dir;
    if (bias === "pozitiv") dir = "presiune de cumpărare";
    else if (bias === "negativ") dir = "presiune de vânzare";
    else if (bias === "neutru") dir = "flux relativ echilibrat";
    else dir = bias;

    let main = dir;
    if (strength) main += ` (${strength})`;

    let sub = "Regimul fluxului de piață în acest snapshot (direcție și intensitate).";
    if (bias === "negativ" && strength === "puternic") {
      sub = "Vânzare dominantă recent; într-un singur snapshot nu implică neapărat un trend, ci descrie regimul curent al fluxului.";
    } else if (bias === "pozitiv" && strength === "puternic") {
      sub = "Cumpărare dominantă recent; contextul poate susține fie continuarea mișcării, fie o normalizare în jurul nivelului modelului.";
    }

    return { main, sub };
  }

  function buildLiquidityText(regime, strength) {
    if (!regime) return { main: "n/a", sub: "Nu există suficiente date pentru a evalua Liquidity Regime." };

    let reg;
    if (regime === "ridicată") reg = "regim de lichiditate ridicată";
    else if (regime === "moderată" || regime === "normală") reg = "regim de lichiditate moderată";
    else if (regime === "scăzută") reg = "regim de lichiditate scăzută";
    else reg = regime;

    let main = reg;
    if (strength) main += ` (${strength})`;

    let sub = "Nivel general al ordelor și al volumului în acest context.";
    if (regime === "scăzută") {
      sub = "În regimuri de lichiditate scăzută, mișcările pot fi mai bruște și mai sensibile la fluxuri punctuale.";
    } else if (regime === "ridicată") {
      sub = "În regimuri de lichiditate ridicată, mișcările tind să fie mai greu de deplasat de ordine izolate.";
    }

    return { main, sub };
  }

  // extrage id-ul 1–8 din market_regime (id/key/label)
  function getRegimeIdFromMarketRegime(marketRegime) {
    if (!marketRegime) return null;

    // 1) dacă avem direct un număr (id)
    if (typeof marketRegime === "number") {
      if (marketRegime >= 1 && marketRegime <= 8) return marketRegime;
    }

    // 2) dacă e obiect cu .id
    if (typeof marketRegime === "object" && marketRegime !== null) {
      if (typeof marketRegime.id === "number" &&
          marketRegime.id >= 1 && marketRegime.id <= 8) {
        return marketRegime.id;
      }
    }

    // 3) dacă avem .key
    let key = null;
    if (typeof marketRegime === "object" && marketRegime !== null && typeof marketRegime.key === "string") {
      key = marketRegime.key.toLowerCase();
    }

    if (!key) {
      // 4) încercăm să deducem din label (string sau obiect.label)
      let label = null;
      if (typeof marketRegime === "string") {
        label = marketRegime;
      } else if (typeof marketRegime === "object" && typeof marketRegime.label === "string") {
        label = marketRegime.label;
      }

      if (label) {
        const norm = label.toLowerCase();
        if (norm.includes("fragilitate maxim")) key = "fragility_max";
        else if (norm.includes("bearish structural")) key = "bearish_structural";
        else if (norm.includes("piață inert") || norm.includes("piata inert")) key = "inert_below";
        else if (norm.includes("echilibru sănătos") || norm.includes("echilibru sanatos")) key = "equilibrium";
        else if (norm.includes("acumulare ordonat")) key = "accumulation";
        else if (norm.includes("expansiune sănătoas") || norm.includes("expansiune sanatoas")) key = "expansion";
        else if (norm.includes("fragilitate bullish")) key = "fragility_bullish";
        else if (norm.includes("tranziție de regim") || norm.includes("tranzitie de regim")) key = "regime_transition";
      }
    }

    if (!key) return null;

    // mapping key → id
    switch (key) {
      case "fragility_max":        return 1;
      case "bearish_struct":      // în caz că e altă variantă
      case "bearish_structural":   return 2;
      case "inert_below":          return 3;
      case "equilibrium":          return 4;
      case "accumulation":         return 5;
      case "expansion":            return 6;
      case "fragility_bullish":    return 7;
      case "regime_transition":    return 8;
      default: return null;
    }
  }

  // determină unul dintre cele 8 regimuri canonice, sau null dacă nu se potrivește clar
  function determineRegime(diffPct, flowBias, liqRegime) {
    // poziționare față de model
    let pos;
    if (!Number.isFinite(diffPct)) {
      pos = null;
    } else if (diffPct < -0.005) {
      pos = "below";  // sub model
    } else if (diffPct > 0.005) {
      pos = "above";  // peste model
    } else {
      pos = "around"; // la model
    }

    // normalizare flowBias
    const fb = (flowBias || "").toString().toLowerCase();
    let flow = null;
    if (fb.startsWith("pozit")) flow = "buy";
    else if (fb.startsWith("negat")) flow = "sell";
    else if (fb.startsWith("neutr")) flow = "neutral";

    // normalizare liquidity_regime
    const lr = (liqRegime || "").toString().toLowerCase();
    let liq = null;
    if (lr.includes("scaz") || lr.includes("scăz")) liq = "low";
    else if (lr.includes("ridic")) liq = "high";
    else if (lr.includes("moder") || lr.includes("normal")) liq = "mid";

    if (!pos || !flow || !liq) return null;

    // mapping exact pe cele 8 situații definite
    if (pos === "below" && flow === "sell" && liq === "low") return 1; // fragilitate maximă
    if (pos === "below" && flow === "sell" && liq === "mid") return 2; // bearish structural
    if (pos === "below" && flow === "neutral" && liq === "low") return 3; // piață inertă
    if (pos === "around" && flow === "neutral" && liq === "mid") return 4; // echilibru sănătos
    if (pos === "around" && flow === "buy" && liq === "high") return 5; // acumulare ordonată
    if (pos === "above" && flow === "buy" && liq === "high") return 6; // expansiune sănătoasă
    if (pos === "above" && flow === "buy" && liq === "low") return 7; // fragilitate bullish
    if (pos === "above" && flow === "sell" && liq === "low") return 8; // tranziție de regim

    return null;
  }

  function highlightRegime(regimeId) {
    const items = document.querySelectorAll(".regime-item");
    items.forEach(el => el.classList.remove("regime-active"));
    if (!regimeId) return;
    const target = document.getElementById("regime-" + regimeId);
    if (target) {
      target.classList.add("regime-active");
    }
  }

  async function loadState() {
    const priceBtcEl     = document.getElementById("price-btc");
    const priceModelEl   = document.getElementById("price-model");
    const priceSourceEl  = document.getElementById("price-source");
    const diffMainEl     = document.getElementById("diff-main");
    const diffSubEl      = document.getElementById("diff-sub");
    const bandTrackEl    = document.getElementById("band-track");
    const bandMarkerEl   = document.getElementById("band-marker");

    const signalChip     = document.getElementById("signal-chip");
    const signalLabelEl  = document.getElementById("signal-label");
    const headlineEl     = document.getElementById("headline");
    const messageEl      = document.getElementById("context-message");
    const metaEl         = document.getElementById("context-meta");
    const errorEl        = document.getElementById("context-error");

    const flowMainEl     = document.getElementById("flow-main");
    const flowSubEl      = document.getElementById("flow-sub");
    const liqMainEl      = document.getElementById("liquidity-main");
    const liqSubEl       = document.getElementById("liquidity-sub");

    try {
      if (errorEl) errorEl.textContent = "";

      const res = await fetch(STATE_URL + "?t=" + Date.now(), {
        cache: "no-store"
      });
      if (!res.ok) throw new Error("HTTP " + res.status);
      const state = await res.json();

      const modelPrice   = state.model_price_usd;
      const btcPrice     = typeof state.price_usd === "number" ? state.price_usd : state.spot;
      const priceSource  = state.price_source;
      const signal       = state.signal;
      const message      = state.message;

      const flowBias     = state.flow_bias;
      const flowStrength = state.flow_strength;
      const liqRegime    = state.liquidity_regime;
      const liqStrength  = state.liquidity_strength;

      const prob         = state.signal_probability;
      const horizonHours = state.signal_prob_horizon_hours || 24;

      const marketRegime = state.market_regime; // obiectul canonic {id, key, label, description} sau string

      // Prețuri (snapshot)
      if (priceBtcEl) {
        if (Number.isFinite(btcPrice)) {
          priceBtcEl.textContent = USD_FMT.format(btcPrice) + " USD";
        } else {
          priceBtcEl.textContent = "–";
        }
      }
      if (priceModelEl) {
        if (Number.isFinite(modelPrice)) {
          priceModelEl.textContent = USD_FMT.format(modelPrice) + " USD";
        } else {
          priceModelEl.textContent = "–";
        }
      }

      // Sursa prețului BTC
      if (priceSourceEl) {
        let srcText = "Sursă preț: necunoscută";

        if (priceSource === "spot") {
          srcText = "Sursă preț: spot (piață cash BTC)";
        } else if (priceSource === "model") {
          srcText = "Sursă preț: derivat din modelul intern";
        } else if (typeof priceSource === "string" && priceSource.trim() !== "") {
          srcText = "Sursă preț: " + priceSource;
        }

        priceSourceEl.textContent = srcText;
      }

      // Diferență + marker pe bandă
      const diffInfo = buildDiff(modelPrice, btcPrice);
      if (diffMainEl) {
        diffMainEl.textContent = diffInfo.main;
        diffMainEl.className = "diff-text-main " + diffInfo.className;
      }
      if (diffSubEl) {
        diffSubEl.textContent = diffInfo.sub;
      }
      positionMarker(diffInfo.pct, bandTrackEl, bandMarkerEl);

      // Signal -> headline + chip
      const sigInfo = mapSignal(signal);
      if (signalLabelEl) signalLabelEl.textContent = sigInfo.label;
      if (headlineEl) {
        headlineEl.textContent = sigInfo.headline;
        headlineEl.className = "headline " + sigInfo.className;
      }
      if (signalChip) {
        signalChip.className = "signal-chip " + sigInfo.className;
      }

      // Mesaj coeziv
      if (messageEl) {
        messageEl.textContent =
          message ||
          "Nu există un mesaj coeziv explicit pentru acest moment. Mecanismul este în modul de observație.";
      }

      // Meta (frecvență istorică)
      if (metaEl) {
        if (typeof prob === "number" && Number.isFinite(prob)) {
          const p = PCT_FMT.format(prob * 100);
          metaEl.innerHTML =
            `Context construit pe baza poziționării BTC față de nivelul modelului, a Flow Regime și a Liquidity Regime, ` +
            `ținând cont de frecvența istorică a contextelor similare (≈ ${p}% din cazuri pe ~${horizonHours}h).`;
        } else {
          metaEl.textContent =
            "Context construit pe baza poziționării BTC față de nivelul modelului, a Flow Regime și a Liquidity Regime, raportate la distribuția istorică a contextelor similare.";
        }
      }

      // Flow
      const flowInfo = buildFlowText(flowBias, flowStrength);
      if (flowMainEl) flowMainEl.textContent = flowInfo.main;
      if (flowSubEl) flowSubEl.textContent = flowInfo.sub;

      // Lichiditate
      const liqInfo = buildLiquidityText(liqRegime, liqStrength);
      if (liqMainEl) liqMainEl.textContent = liqInfo.main;
      if (liqSubEl) liqSubEl.textContent = liqInfo.sub;

      // Regim de piață canonic – întâi încercăm direct din state.market_regime;
      // dacă nu avem ceva clar, cădem pe determinarea locală din triada (diff/flow/liq).
      let regimeId = getRegimeIdFromMarketRegime(marketRegime);
      if (!regimeId) {
        regimeId = determineRegime(diffInfo.pct, flowBias, liqRegime);
      }
      highlightRegime(regimeId);

    } catch (err) {
      console.error(err);
      if (errorEl) {
        errorEl.textContent =
          "Nu am putut încărca contextul mecanismului. Verifică coeziv_state.json sau workflow-ul de backend.";
      }
      highlightRegime(null);
    }
  }

  // încărcare inițială (snapshot-ul zilei)
  loadState().catch(console.error);
</script>
</body>
</html>
