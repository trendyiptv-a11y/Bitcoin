<!DOCTYPE html>
<html lang="ro">
<head>
  <meta charset="UTF-8" />
  <title>Coeziv BTC Market Context ‚Äî Daily Snapshot</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #020617;
      --bg-card: rgba(15, 23, 42, 0.98);
      --bg-chip: rgba(15, 23, 42, 0.9);
      --border-soft: #1f2937;
      --text-main: #e5e7eb;
      --text-muted: #9ca3af;
      --text-soft: #6b7280;
      --accent-long: #22c55e;
      --accent-short: #f97373;
      --accent-neutral: #6366f1;
      --band-bg: linear-gradient(90deg, #22c55e 0%, #e5e7eb 50%, #f97373 100%);
      --band-track: rgba(15, 23, 42, 0.9);
      --band-border: #1f2937;
      --bg-btc: rgba(17, 24, 39, 0.95);
      --bg-model: rgba(15, 23, 42, 0.9);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Segoe UI", sans-serif;
      background:
        radial-gradient(circle at top left, #0f172a 0, #020617 38%, #020617 100%),
        radial-gradient(circle at bottom right, #111827 0, #020617 45%, #020617 100%);
      color: var(--text-main);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .shell {
      width: 100%;
      max-width: 960px;
      padding: 16px;
    }

    .card {
      border-radius: 24px;
      border: 1px solid var(--border-soft);
      background: var(--bg-card);
      padding: 18px 20px 14px;
      box-shadow: 0 26px 60px rgba(15, 23, 42, 0.9);
    }

    .layout {
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 1.2fr);
      gap: 20px;
      align-items: stretch;
    }

    @media (max-width: 820px) {
      .layout {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .label-main {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--text-soft);
    }

    .chip-small {
      font-size: 10px;
      color: var(--text-soft);
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid var(--border-soft);
      background: var(--bg-chip);
    }

    /* ST√ÇNGA ‚Äì PRE»öURI + BARƒÇ */
    .prices-block {
      margin-top: 6px;
      margin-bottom: 14px;
    }

    .prices-row {
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 0.9fr);
      gap: 10px;
    }

    .price-box {
      border-radius: 16px;
      border: 1px solid var(--border-soft);
      padding: 10px 12px;
    }

    .price-box.btc {
      background: var(--bg-btc);
    }

    .price-box.model {
      background: var(--bg-model);
    }

    .price-label {
      font-size: 11px;
      color: var(--text-soft);
      margin-bottom: 2px;
    }

    .price-value-btc {
      font-size: 24px;
      font-weight: 600;
      color: var(--text-main);
    }

    .price-value-model {
      font-size: 14px;
      font-weight: 500;
      color: var(--text-muted);
    }

    .price-sub {
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 2px;
    }

    .price-source {
      font-size: 10px;
      color: var(--text-soft);
      margin-top: 2px;
    }

    .band-block {
      margin-top: 10px;
    }

    .band-label {
      font-size: 11px;
      color: var(--text-soft);
      margin-bottom: 4px;
    }

    .band-track {
      position: relative;
      width: 100%;
      height: 12px;
      border-radius: 999px;
      border: 1px solid var(--band-border);
      background: var(--band-bg);
      overflow: hidden;
    }

    .band-center-line {
      position: absolute;
      left: 50%;
      top: 0;
      bottom: 0;
      width: 1px;
      background: rgba(15, 23, 42, 0.7);
      opacity: 0.7;
    }

    .band-marker {
      position: absolute;
      top: -4px;
      width: 0;
      height: 0;
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
      border-bottom: 8px solid #e5e7eb;
      filter: drop-shadow(0 0 4px rgba(0,0,0,0.7));
      transition: left 0.3s ease-out;
    }

    .band-legend {
      margin-top: 4px;
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      color: var(--text-soft);
    }

    .diff-text-main {
      margin-top: 6px;
      font-size: 13px;
      font-weight: 500;
      color: var(--text-main);
    }

    .diff-text-main.positive {
      color: var(--accent-short);
    }

    .diff-text-main.negative {
      color: var(--accent-long);
    }

    .diff-text-sub {
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 2px;
    }

    /* DREAPTA ‚Äì CONTEXT */
    .status-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .signal-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid var(--border-soft);
      background: var(--bg-chip);
      font-size: 11px;
      color: var(--text-muted);
    }

    .signal-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: var(--accent-neutral);
    }

    .signal-chip.long .signal-dot {
      background: var(--accent-long);
    }

    .signal-chip.short .signal-dot {
      background: var(--accent-short);
    }

    .headline {
      font-size: 16px;
      font-weight: 600;
      color: var(--text-main);
      margin-bottom: 6px;
    }

    .headline.long {
      color: var(--accent-long);
    }

    .headline.short {
      color: var(--accent-short);
    }

    .context-text {
      font-size: 13px;
      color: var(--text-main);
      line-height: 1.5;
      margin-bottom: 8px;
    }

    .meta-text {
      font-size: 11px;
      color: var(--text-muted);
    }

    .error-text {
      font-size: 11px;
      color: var(--accent-short);
      margin-top: 4px;
    }

    .tags-grid {
      margin-top: 12px;
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
    }

    .tag-box {
      border-radius: 14px;
      border: 1px solid var(--border-soft);
      background: rgba(15, 23, 42, 0.92);
      padding: 8px 10px;
    }

    .tag-label {
      font-size: 11px;
      color: var(--text-soft);
      margin-bottom: 2px;
    }

    .tag-main {
      font-size: 12px;
      font-weight: 500;
      color: var(--text-main);
    }

    .tag-sub {
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 1px;
    }

    /* CARD REGIMURI DE PIA»öƒÇ */
    .market-regimes-card {
      margin-top: 28px;
      padding: 18px;
      border-radius: 22px;
      border: 1px solid var(--border-soft);
      background: rgba(15, 23, 42, 0.96);
    }

    .market-regimes-title {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 14px;
      color: var(--text-main);
    }

    .market-regimes-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
    }

    .regime-item {
      border-radius: 16px;
      padding: 10px 12px;
      border: 1px solid var(--border-soft);
      background: rgba(2, 6, 23, 0.9);
      transition: border-color 0.18s ease-out, box-shadow 0.18s ease-out, transform 0.18s ease-out, background 0.18s ease-out;
    }

    .regime-title {
      font-size: 12px;
      font-weight: 600;
      margin-bottom: 4px;
    }

    .regime-desc {
      font-size: 11px;
      color: var(--text-muted);
    }

    .regime-note {
      font-size: 11px;
      margin-top: 4px;
      color: #d1d5db;
    }

    /* accente vizuale pe marginea st√¢ngƒÉ */
    .fragile { border-left: 3px solid #f97373; }
    .bearish { border-left: 3px solid #fb7185; }
    .inert { border-left: 3px solid #64748b; }
    .balanced { border-left: 3px solid #94a3b8; }
    .accumulation { border-left: 3px solid #38bdf8; }
    .expansion { border-left: 3px solid #22c55e; }
    .reversal { border-left: 3px solid #eab308; }

    /* highlight automat pentru regimul curent ‚Äì mult mai vizibil */
    .regime-active {
      border-color: #ffffff;
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.14), rgba(15, 23, 42, 0.98));
      box-shadow: 0 0 0 1px rgba(248, 250, 252, 0.5), 0 14px 32px rgba(15, 23, 42, 0.95);
      transform: translateY(-2px);
    }

    .disclaimer {
      margin-top: 10px;
      font-size: 10px;
      color: var(--text-soft);
      text-align: left;
    }
  </style>
</head>
<body>
<div class="shell">
  <div class="card">
    <div class="card-header">
      <div class="label-main">COEZIV BTC MARKET CONTEXT ‚Äî DAILY SNAPSHOT</div>
      <div class="chip-small">Snapshot zilnic de context, nu semnal de intrare</div>
    </div>

    <div class="layout">
      <!-- ST√ÇNGA: PRE»öURI + BARƒÇ -->
      <section>
        <div class="prices-block">
          <div class="prices-row">
            <div class="price-box btc">
              <div class="price-label">Pre»õ de referin»õƒÉ BTC (snapshot)</div>
              <div class="price-value-btc" id="price-btc">‚Äì</div>
              <div class="price-sub">
                Pre»õul BTC utilizat de mecanism la momentul generƒÉrii snapshotului.
              </div>
              <div class="price-source" id="price-source">
                SursƒÉ pre»õ: ‚Äì
              </div>
            </div>
            <div class="price-box model">
              <div class="price-label">Nivel de referin»õƒÉ al mecanismului</div>
              <div class="price-value-model" id="price-model">‚Äì</div>
              <div class="price-sub">
                Nivelul estimat de model pentru BTC √Æn contextul acestui snapshot.
              </div>
            </div>
          </div>
        </div>

        <div class="band-block">
          <div class="band-label">Pozi»õionarea BTC fa»õƒÉ de nivelul modelului</div>
          <div class="band-track" id="band-track">
            <div class="band-center-line"></div>
            <div class="band-marker" id="band-marker" style="left:50%;"></div>
          </div>
          <div class="band-legend">
            <span>sub nivelul modelului</span>
            <span>√Æn zona modelului</span>
            <span>peste nivelul modelului</span>
          </div>

          <div class="diff-text-main" id="diff-main">
            Nu putem evalua pozi»õionarea fa»õƒÉ de nivelul modelului.
          </div>
          <div class="diff-text-sub" id="diff-sub"></div>
        </div>
      </section>

      <!-- DREAPTA: CONTEXT + FLUX / LICHIDITATE -->
      <section>
        <div class="status-row">
          <div class="headline" id="headline">
            Se √ÆncarcƒÉ Market Context...
          </div>
          <div>
            <span id="signal-chip" class="signal-chip">
              <span class="signal-dot"></span>
              <span id="signal-label">Market Context: neutru</span>
            </span>
          </div>
        </div>

        <p class="context-text" id="context-message">
          A»ôteptƒÉm mesajul coeziv generat de mecanism.
        </p>

        <div class="meta-text" id="context-meta">
          Context construit pe baza pozi»õionƒÉrii BTC fa»õƒÉ de nivelul modelului, a Flow Regime »ôi a Liquidity Regime, raportate la distribu»õia istoricƒÉ a contextelor similare.
        </div>

        <div class="error-text" id="context-error"></div>

        <div class="tags-grid">
          <div class="tag-box">
            <div class="tag-label">Flow Regime</div>
            <div class="tag-main" id="flow-main">n/a</div>
            <div class="tag-sub" id="flow-sub">
              Regimul fluxului de pia»õƒÉ √Æn acest snapshot (direc»õie »ôi intensitate).
            </div>
          </div>
          <div class="tag-box">
            <div class="tag-label">Liquidity Regime</div>
            <div class="tag-main" id="liquidity-main">n/a</div>
            <div class="tag-sub" id="liquidity-sub">
              Regimul de lichiditate ‚Äî c√¢t de ‚ÄûdensƒÉ‚Äù sau ‚Äûsub»õire‚Äù este pia»õa √Æn acest context.
            </div>
          </div>
        </div>
      </section>
    </div>

    <!-- CARD REGIMURI DE PIA»öƒÇ -->
    <div class="market-regimes-card">
      <div class="market-regimes-title">
        Situa»õii de pia»õƒÉ recurente (ghid de interpretare)
      </div>

      <div class="market-regimes-grid">

        <div class="regime-item fragile" id="regime-1">
          <div class="regime-title">1Ô∏è‚É£ Fragilitate maximƒÉ</div>
          <div class="regime-desc">
            Sub model ¬∑ V√¢nzare ¬∑ Lichiditate scƒÉzutƒÉ
          </div>
          <div class="regime-note">
            Mi»ôcƒÉrile sunt amplificate de absen»õa market makerilor. Pia»õa este dezechilibratƒÉ temporar.
          </div>
        </div>

        <div class="regime-item bearish" id="regime-2">
          <div class="regime-title">2Ô∏è‚É£ Bearish structural</div>
          <div class="regime-desc">
            Sub model ¬∑ V√¢nzare ¬∑ Lichiditate moderatƒÉ
          </div>
          <div class="regime-note">
            V√¢nzarea este absorbitƒÉ ordonat. Pia»õa acceptƒÉ niveluri mai joase.
          </div>
        </div>

        <div class="regime-item inert" id="regime-3">
          <div class="regime-title">3Ô∏è‚É£ Pia»õƒÉ inertƒÉ</div>
          <div class="regime-desc">
            Sub model ¬∑ Echilibru ¬∑ Lichiditate scƒÉzutƒÉ
          </div>
          <div class="regime-note">
            Nici cumpƒÉrƒÉtori, nici v√¢nzƒÉtori convingƒÉtori. Stare de tranzi»õie.
          </div>
        </div>

        <div class="regime-item balanced" id="regime-4">
          <div class="regime-title">4Ô∏è‚É£ Echilibru sƒÉnƒÉtos</div>
          <div class="regime-desc">
            La model ¬∑ Echilibru ¬∑ Lichiditate moderatƒÉ
          </div>
          <div class="regime-note">
            Pia»õƒÉ stabilƒÉ, market makerii confortabili, volatilitate redusƒÉ.
          </div>
        </div>

        <div class="regime-item accumulation" id="regime-5">
          <div class="regime-title">5Ô∏è‚É£ Accumulare ordonatƒÉ</div>
          <div class="regime-desc">
            La model ¬∑ CumpƒÉrare ¬∑ Lichiditate ridicatƒÉ
          </div>
          <div class="regime-note">
            Interes real, dar fƒÉrƒÉ grabƒÉ. Pre»õul rƒÉm√¢ne ancorat.
          </div>
        </div>

        <div class="regime-item expansion" id="regime-6">
          <div class="regime-title">6Ô∏è‚É£ Expansiune sƒÉnƒÉtoasƒÉ</div>
          <div class="regime-desc">
            Peste model ¬∑ CumpƒÉrare ¬∑ Lichiditate ridicatƒÉ
          </div>
          <div class="regime-note">
            Momentum sus»õinut √Æntr-o pia»õƒÉ elasticƒÉ. Mi»ôcare validƒÉ.
          </div>
        </div>

        <div class="regime-item fragile" id="regime-7">
          <div class="regime-title">7Ô∏è‚É£ Fragilitate bullish</div>
          <div class="regime-desc">
            Peste model ¬∑ CumpƒÉrare ¬∑ Lichiditate scƒÉzutƒÉ
          </div>
          <div class="regime-note">
            Raliu rapid √Æntr-o pia»õƒÉ sub»õire. Risc de retragere bruscƒÉ.
          </div>
        </div>

        <div class="regime-item reversal" id="regime-8">
          <div class="regime-title">8Ô∏è‚É£ Tranzi»õie de regim</div>
          <div class="regime-desc">
            Peste model ¬∑ V√¢nzare ¬∑ Lichiditate scƒÉzutƒÉ
          </div>
          <div class="regime-note">
            Semn de distribu»õie sau schimbare de comportament al pie»õei.
          </div>
        </div>

      </div>
    </div>

    <div class="disclaimer">
      <strong>Disclaimer</strong> ¬∑ Acest dashboard oferƒÉ un snapshot zilnic de context de pia»õƒÉ, bazat pe modele cantitative »ôi date istorice. Informa»õiile descriu regimul de pia»õƒÉ observat la momentul snapshotului »ôi nu constituie recomandƒÉri de investi»õii sau semnale de tranzac»õionare.
    </div>
  </div>
</div>

<script>
  const STATE_URL = "coeziv_state.json";

  const USD_FMT = new Intl.NumberFormat("en-US", {
    minimumFractionDigits: 0,
    maximumFractionDigits: 0
  });
  const PCT_FMT = new Intl.NumberFormat("en-US", {
    minimumFractionDigits: 1,
    maximumFractionDigits: 1
  });

  function mapSignal(signal) {
    const s = (signal || "").toLowerCase();
    if (s === "long") {
      return {
        label: "Market Context: bias pozitiv",
        headline: "Market Context: bias pozitiv",
        className: "long"
      };
    }
    if (s === "short") {
      return {
        label: "Market Context: bias negativ",
        headline: "Market Context: bias negativ",
        className: "short"
      };
    }
    return {
      label: "Market Context: neutru",
      headline: "Market Context: neutru",
      className: ""
    };
  }

  function buildDiff(modelPrice, btcPrice) {
    if (!Number.isFinite(modelPrice) || !Number.isFinite(btcPrice) || modelPrice <= 0) {
      return {
        main: "Nu putem evalua pozi»õionarea fa»õƒÉ de nivelul modelului.",
        sub: "",
        pct: null,
        className: ""
      };
    }
    const diff = btcPrice - modelPrice;
    const pct = diff / modelPrice;
    const absDiff = Math.abs(diff);
    const absPct = Math.abs(pct) * 100;

    const pctStr = PCT_FMT.format(absPct) + "%";
    const usdStr = USD_FMT.format(absDiff) + " USD";

    if (Math.abs(pct) < 0.005) {
      return {
        main: "BTC este foarte aproape de nivelul estimat de model.",
        sub: `Abatere ‚âà ${usdStr} (${pctStr}).`,
        pct,
        className: ""
      };
    } else if (pct > 0) {
      return {
        main: "BTC este pozi»õionat peste nivelul estimat de model.",
        sub: `Aproximativ +${usdStr} (+${pctStr}) peste nivelul modelului.`,
        pct,
        className: "positive"
      };
    } else {
      return {
        main: "BTC este pozi»õionat sub nivelul estimat de model.",
        sub: `Aproximativ -${usdStr} (-${pctStr}) sub nivelul modelului.`,
        pct,
        className: "negative"
      };
    }
  }

  function positionMarker(pct, trackEl, markerEl) {
    if (!trackEl || !markerEl) return;
    if (pct == null || !Number.isFinite(pct)) {
      markerEl.style.left = "50%";
      return;
    }
    const maxPct = 0.04;
    const r = Math.max(-maxPct, Math.min(maxPct, pct));
    const offset = (r / maxPct) * 40; // ¬±40% din lƒÉ»õime
    const pos = 50 + offset;
    markerEl.style.left = pos + "%";
  }

  function buildFlowText(bias, strength) {
    if (!bias) return { main: "n/a", sub: "Nu existƒÉ suficiente date pentru a evalua Flow Regime." };
    let dir;
    if (bias === "pozitiv") dir = "presiune de cumpƒÉrare";
    else if (bias === "negativ") dir = "presiune de v√¢nzare";
    else if (bias === "neutru") dir = "flux relativ echilibrat";
    else dir = bias;

    let main = dir;
    if (strength) main += ` (${strength})`;

    let sub = "Regimul fluxului de pia»õƒÉ √Æn acest snapshot (direc»õie »ôi intensitate).";
    if (bias === "negativ" && strength === "puternic") {
      sub = "V√¢nzare dominantƒÉ recent; √Æntr-un singur snapshot nu implicƒÉ neapƒÉrat un trend, ci descrie regimul curent al fluxului.";
    } else if (bias === "pozitiv" && strength === "puternic") {
      sub = "CumpƒÉrare dominantƒÉ recent; contextul poate sus»õine fie continuarea mi»ôcƒÉrii, fie o normalizare √Æn jurul nivelului modelului.";
    }

    return { main, sub };
  }

  function buildLiquidityText(regime, strength) {
    if (!regime) return { main: "n/a", sub: "Nu existƒÉ suficiente date pentru a evalua Liquidity Regime." };

    let reg;
    if (regime === "ridicatƒÉ") reg = "regim de lichiditate ridicatƒÉ";
    else if (regime === "moderatƒÉ" || regime === "normalƒÉ") reg = "regim de lichiditate moderatƒÉ";
    else if (regime === "scƒÉzutƒÉ") reg = "regim de lichiditate scƒÉzutƒÉ";
    else reg = regime;

    let main = reg;
    if (strength) main += ` (${strength})`;

    let sub = "Nivel general al ordelor »ôi al volumului √Æn acest context.";
    if (regime === "scƒÉzutƒÉ") {
      sub = "√én regimuri de lichiditate scƒÉzutƒÉ, mi»ôcƒÉrile pot fi mai bru»ôte »ôi mai sensibile la fluxuri punctuale.";
    } else if (regime === "ridicatƒÉ") {
      sub = "√én regimuri de lichiditate ridicatƒÉ, mi»ôcƒÉrile tind sƒÉ fie mai greu de deplasat de ordine izolate.";
    }

    return { main, sub };
  }

  // extrage id-ul 1‚Äì8 din market_regime (id/key/label)
  function getRegimeIdFromMarketRegime(marketRegime) {
    if (!marketRegime) return null;

    // 1) dacƒÉ avem direct un numƒÉr (id)
    if (typeof marketRegime === "number") {
      if (marketRegime >= 1 && marketRegime <= 8) return marketRegime;
    }

    // 2) dacƒÉ e obiect cu .id
    if (typeof marketRegime === "object" && marketRegime !== null) {
      if (typeof marketRegime.id === "number" &&
          marketRegime.id >= 1 && marketRegime.id <= 8) {
        return marketRegime.id;
      }
    }

    // 3) dacƒÉ avem .key
    let key = null;
    if (typeof marketRegime === "object" && marketRegime !== null && typeof marketRegime.key === "string") {
      key = marketRegime.key.toLowerCase();
    }

    if (!key) {
      // 4) √ÆncercƒÉm sƒÉ deducem din label (string sau obiect.label)
      let label = null;
      if (typeof marketRegime === "string") {
        label = marketRegime;
      } else if (typeof marketRegime === "object" && typeof marketRegime.label === "string") {
        label = marketRegime.label;
      }

      if (label) {
        const norm = label.toLowerCase();
        if (norm.includes("fragilitate maxim")) key = "fragility_max";
        else if (norm.includes("bearish structural")) key = "bearish_structural";
        else if (norm.includes("pia»õƒÉ inert") || norm.includes("piata inert")) key = "inert_below";
        else if (norm.includes("echilibru sƒÉnƒÉtos") || norm.includes("echilibru sanatos")) key = "equilibrium";
        else if (norm.includes("acumulare ordonat")) key = "accumulation";
        else if (norm.includes("expansiune sƒÉnƒÉtoas") || norm.includes("expansiune sanatoas")) key = "expansion";
        else if (norm.includes("fragilitate bullish")) key = "fragility_bullish";
        else if (norm.includes("tranzi»õie de regim") || norm.includes("tranzitie de regim")) key = "regime_transition";
      }
    }

    if (!key) return null;

    // mapping key ‚Üí id
    switch (key) {
      case "fragility_max":        return 1;
      case "bearish_struct":      // √Æn caz cƒÉ e altƒÉ variantƒÉ
      case "bearish_structural":   return 2;
      case "inert_below":          return 3;
      case "equilibrium":          return 4;
      case "accumulation":         return 5;
      case "expansion":            return 6;
      case "fragility_bullish":    return 7;
      case "regime_transition":    return 8;
      default: return null;
    }
  }

  // determinƒÉ unul dintre cele 8 regimuri canonice, sau null dacƒÉ nu se potrive»ôte clar
  function determineRegime(diffPct, flowBias, liqRegime) {
    // pozi»õionare fa»õƒÉ de model
    let pos;
    if (!Number.isFinite(diffPct)) {
      pos = null;
    } else if (diffPct < -0.005) {
      pos = "below";  // sub model
    } else if (diffPct > 0.005) {
      pos = "above";  // peste model
    } else {
      pos = "around"; // la model
    }

    // normalizare flowBias
    const fb = (flowBias || "").toString().toLowerCase();
    let flow = null;
    if (fb.startsWith("pozit")) flow = "buy";
    else if (fb.startsWith("negat")) flow = "sell";
    else if (fb.startsWith("neutr")) flow = "neutral";

    // normalizare liquidity_regime
    const lr = (liqRegime || "").toString().toLowerCase();
    let liq = null;
    if (lr.includes("scaz") || lr.includes("scƒÉz")) liq = "low";
    else if (lr.includes("ridic")) liq = "high";
    else if (lr.includes("moder") || lr.includes("normal")) liq = "mid";

    if (!pos || !flow || !liq) return null;

    // mapping exact pe cele 8 situa»õii definite
    if (pos === "below" && flow === "sell" && liq === "low") return 1; // fragilitate maximƒÉ
    if (pos === "below" && flow === "sell" && liq === "mid") return 2; // bearish structural
    if (pos === "below" && flow === "neutral" && liq === "low") return 3; // pia»õƒÉ inertƒÉ
    if (pos === "around" && flow === "neutral" && liq === "mid") return 4; // echilibru sƒÉnƒÉtos
    if (pos === "around" && flow === "buy" && liq === "high") return 5; // acumulare ordonatƒÉ
    if (pos === "above" && flow === "buy" && liq === "high") return 6; // expansiune sƒÉnƒÉtoasƒÉ
    if (pos === "above" && flow === "buy" && liq === "low") return 7; // fragilitate bullish
    if (pos === "above" && flow === "sell" && liq === "low") return 8; // tranzi»õie de regim

    return null;
  }

  function highlightRegime(regimeId) {
    const items = document.querySelectorAll(".regime-item");
    items.forEach(el => el.classList.remove("regime-active"));
    if (!regimeId) return;
    const target = document.getElementById("regime-" + regimeId);
    if (target) {
      target.classList.add("regime-active");
    }
  }

  async function loadState() {
    const priceBtcEl     = document.getElementById("price-btc");
    const priceModelEl   = document.getElementById("price-model");

          priceBtcEl.textContent = "‚Äì";
        }
      }
      if (priceModelEl) {
        if (Number.isFinite(modelPrice)) {
          priceModelEl.textContent = USD_FMT.format(modelPrice) + " USD";
        } else {
          priceModelEl.textContent = "‚Äì";
        }
      }

      // Sursa pre»õului BTC
      if (priceSourceEl) {
        let srcText = "SursƒÉ pre»õ: necunoscutƒÉ";

        if (priceSource === "spot") {
          srcText = "SursƒÉ pre»õ: spot (pia»õƒÉ cash BTC)";
        } else if (priceSource === "model") {
          srcText = "SursƒÉ pre»õ: derivat din modelul intern";
        } else if (typeof priceSource === "string" && priceSource.trim() !== "") {
          srcText = "SursƒÉ pre»õ: " + priceSource;
        }

        priceSourceEl.textContent = srcText;
      }

      // Diferen»õƒÉ + marker pe bandƒÉ
      const diffInfo = buildDiff(modelPrice, btcPrice);
      if (diffMainEl) {
        diffMainEl.textContent = diffInfo.main;
        diffMainEl.className = "diff-text-main " + diffInfo.className;
      }
      if (diffSubEl) {
        diffSubEl.textContent = diffInfo.sub;
      }
      positionMarker(diffInfo.pct, bandTrackEl, bandMarkerEl);

      // Signal -> headline + chip
      const sigInfo = mapSignal(signal);
      if (signalLabelEl) signalLabelEl.textContent = sigInfo.label;
      if (headlineEl) {
        headlineEl.textContent = sigInfo.headline;
        headlineEl.className = "headline " + sigInfo.className;
      }
      if (signalChip) {
        signalChip.className = "signal-chip " + sigInfo.className;
      }

      // Mesaj coeziv
      if (messageEl) {
        messageEl.textContent =
          message ||
          "Nu existƒÉ un mesaj coeziv explicit pentru acest moment. Mecanismul este √Æn modul de observa»õie.";
<script>
  const STATE_URL = "coeziv_state.json";

  const USD_FMT = new Intl.NumberFormat("en-US", {
    minimumFractionDigits: 0,
    maximumFractionDigits: 0
  });
  const PCT_FMT = new Intl.NumberFormat("en-US", {
    minimumFractionDigits: 1,
    maximumFractionDigits: 1
  });

  function mapSignal(signal) {
    const s = (signal || "").toLowerCase();
    if (s === "long") {
      return {
        label: "Market Context: bias pozitiv",
        headline: "Market Context: bias pozitiv",
        className: "long"
      };
    }
    if (s === "short") {
      return {
        label: "Market Context: bias negativ",
        headline: "Market Context: bias negativ",
        className: "short"
      };
    }
    return {
      label: "Market Context: neutru",
      headline: "Market Context: neutru",
      className: ""
    };
  }

  function buildDiff(modelPrice, btcPrice) {
    if (!Number.isFinite(modelPrice) || !Number.isFinite(btcPrice) || modelPrice <= 0) {
      return {
        main: "Nu putem evalua pozi»õionarea fa»õƒÉ de nivelul modelului.",
        sub: "",
        pct: null,
        className: ""
      };
    }
    const diff = btcPrice - modelPrice;
    const pct = diff / modelPrice;
    const absDiff = Math.abs(diff);
    const absPct = Math.abs(pct) * 100;

    const pctStr = PCT_FMT.format(absPct) + "%";
    const usdStr = USD_FMT.format(absDiff) + " USD";

    if (Math.abs(pct) < 0.005) {
      return {
        main: "BTC este foarte aproape de nivelul estimat de model.",
        sub: `Abatere ‚âà ${usdStr} (${pctStr}).`,
        pct,
        className: ""
      };
    } else if (pct > 0) {
      return {
        main: "BTC este pozi»õionat peste nivelul estimat de model.",
        sub: `Aproximativ +${usdStr} (+${pctStr}) peste nivelul modelului.`,
        pct,
        className: "positive"
      };
    } else {
      return {
        main: "BTC este pozi»õionat sub nivelul estimat de model.",
        sub: `Aproximativ -${usdStr} (-${pctStr}) sub nivelul modelului.`,
        pct,
        className: "negative"
      };
    }
  }

  function positionMarker(pct, trackEl, markerEl) {
    if (!trackEl || !markerEl) return;
    if (pct == null || !Number.isFinite(pct)) {
      markerEl.style.left = "50%";
      return;
    }
    const maxPct = 0.04;
    const r = Math.max(-maxPct, Math.min(maxPct, pct));
    const offset = (r / maxPct) * 40; // ¬±40% din lƒÉ»õime
    const pos = 50 + offset;
    markerEl.style.left = pos + "%";
  }

  function buildFlowText(bias, strength) {
    if (!bias) return { main: "n/a", sub: "Nu existƒÉ suficiente date pentru a evalua Flow Regime." };
    let dir;
    if (bias === "pozitiv") dir = "presiune de cumpƒÉrare";
    else if (bias === "negativ") dir = "presiune de v√¢nzare";
    else if (bias === "neutru") dir = "flux relativ echilibrat";
    else dir = bias;

    let main = dir;
    if (strength) main += ` (${strength})`;

    let sub = "Regimul fluxului de pia»õƒÉ √Æn acest snapshot (direc»õie »ôi intensitate).";
    if (bias === "negativ" && strength === "puternic") {
      sub = "V√¢nzare dominantƒÉ recent; √Æntr-un singur snapshot nu implicƒÉ neapƒÉrat un trend, ci descrie regimul curent al fluxului.";
    } else if (bias === "pozitiv" && strength === "puternic") {
      sub = "CumpƒÉrare dominantƒÉ recent; contextul poate sus»õine fie continuarea mi»ôcƒÉrii, fie o normalizare √Æn jurul nivelului modelului.";
    }

    return { main, sub };
  }

  function buildLiquidityText(regime, strength) {
    if (!regime) return { main: "n/a", sub: "Nu existƒÉ suficiente date pentru a evalua Liquidity Regime." };

    let reg;
    if (regime === "ridicatƒÉ") reg = "regim de lichiditate ridicatƒÉ";
    else if (regime === "moderatƒÉ" || regime === "normalƒÉ") reg = "regim de lichiditate moderatƒÉ";
    else if (regime === "scƒÉzutƒÉ") reg = "regim de lichiditate scƒÉzutƒÉ";
    else reg = regime;

    let main = reg;
    if (strength) main += ` (${strength})`;

    let sub = "Nivel general al ordelor »ôi al volumului √Æn acest context.";
    if (regime === "scƒÉzutƒÉ") {
      sub = "√én regimuri de lichiditate scƒÉzutƒÉ, mi»ôcƒÉrile pot fi mai bru»ôte »ôi mai sensibile la fluxuri punctuale.";
    } else if (regime === "ridicatƒÉ") {
      sub = "√én regimuri de lichiditate ridicatƒÉ, mi»ôcƒÉrile tind sƒÉ fie mai greu de deplasat de ordine izolate.";
    }

    return { main, sub };
  }

  // ‚úÖ citim regimul canonic din coeziv_state.market_regime
  function getRegimeIdFromMarketRegime(marketRegime) {
    if (!marketRegime) return null;

    // 1) direct numƒÉr
    if (typeof marketRegime === "number") {
      if (marketRegime >= 1 && marketRegime <= 8) return marketRegime;
    }

    // 2) obiect cu .id
    if (typeof marketRegime === "object" && marketRegime !== null) {
      if (typeof marketRegime.id === "number" &&
          marketRegime.id >= 1 && marketRegime.id <= 8) {
        return marketRegime.id;
      }
    }

    // 3) cheie internƒÉ
    let key = null;
    if (typeof marketRegime === "object" && marketRegime !== null && typeof marketRegime.key === "string") {
      key = marketRegime.key.toLowerCase();
    }

    // 4) dacƒÉ nu avem key, √ÆncercƒÉm din label/text
    if (!key) {
      let label = null;
      if (typeof marketRegime === "string") {
        label = marketRegime;
      } else if (typeof marketRegime === "object" && typeof marketRegime.label === "string") {
        label = marketRegime.label;
      }

      if (label) {
        const norm = label.toLowerCase();
        if (norm.includes("fragilitate maxim")) key = "fragility_max";
        else if (norm.includes("bearish structural")) key = "bearish_structural";
        else if (norm.includes("pia»õƒÉ inert") || norm.includes("piata inert")) key = "inert_below";
        else if (norm.includes("echilibru sƒÉnƒÉtos") || norm.includes("echilibru sanatos")) key = "equilibrium";
        else if (norm.includes("acumulare ordonat")) key = "accumulation";
        else if (norm.includes("expansiune sƒÉnƒÉtoas") || norm.includes("expansiune sanatoas")) key = "expansion";
        else if (norm.includes("fragilitate bullish")) key = "fragility_bullish";
        else if (norm.includes("tranzi»õie de regim") || norm.includes("tranzitie de regim")) key = "regime_transition";
      }
    }

    if (!key) return null;

    switch (key) {
      case "fragility_max":      return 1;
      case "bearish_struct":
      case "bearish_structural": return 2;
      case "inert_below":        return 3;
      case "equilibrium":        return 4;
      case "accumulation":       return 5;
      case "expansion":          return 6;
      case "fragility_bullish":  return 7;
      case "regime_transition":  return 8;
      default:                   return null;
    }
  }

  // fallback: determinƒÉ unul dintre cele 8 regimuri, sau null
  function determineRegime(diffPct, flowBias, liqRegime) {
    let pos;
    if (!Number.isFinite(diffPct)) {
      pos = null;
    } else if (diffPct < -0.005) {
      pos = "below";
    } else if (diffPct > 0.005) {
      pos = "above";
    } else {
      pos = "around";
    }

    const fb = (flowBias || "").toString().toLowerCase();
    let flow = null;
    if (fb.startsWith("pozit")) flow = "buy";
    else if (fb.startsWith("negat")) flow = "sell";
    else if (fb.startsWith("neutr")) flow = "neutral";

    const lr = (liqRegime || "").toString().toLowerCase();
    let liq = null;
    if (lr.includes("scaz") || lr.includes("scƒÉz")) liq = "low";
    else if (lr.includes("ridic")) liq = "high";
    else if (lr.includes("moder") || lr.includes("normal")) liq = "mid";

    if (!pos || !flow || !liq) return null;

    if (pos === "below" && flow === "sell" && liq === "low") return 1;
    if (pos === "below" && flow === "sell" && liq === "mid") return 2;
    if (pos === "below" && flow === "neutral" && liq === "low") return 3;
    if (pos === "around" && flow === "neutral" && liq === "mid") return 4;
    if (pos === "around" && flow === "buy" && liq === "high") return 5;
    if (pos === "above" && flow === "buy" && liq === "high") return 6;
    if (pos === "above" && flow === "buy" && liq === "low") return 7;
    if (pos === "above" && flow === "sell" && liq === "low") return 8;

    return null;
  }

  function highlightRegime(regimeId) {
    const items = document.querySelectorAll(".regime-item");
    items.forEach(el => el.classList.remove("regime-active"));
    if (!regimeId) return;
    const target = document.getElementById("regime-" + regimeId);
    if (target) {
      target.classList.add("regime-active");
    }
  }

  async function loadState() {
    const priceBtcEl     = document.getElementById("price-btc");
    const priceModelEl   = document.getElementById("price-model");
    const priceSourceEl  = document.getElementById("price-source");
    const diffMainEl     = document.getElementById("diff-main");
    const diffSubEl      = document.getElementById("diff-sub");
    const bandTrackEl    = document.getElementById("band-track");
    const bandMarkerEl   = document.getElementById("band-marker");

    const signalChip     = document.getElementById("signal-chip");
    const signalLabelEl  = document.getElementById("signal-label");
    const headlineEl     = document.getElementById("headline");
    const messageEl      = document.getElementById("context-message");
    const metaEl         = document.getElementById("context-meta");
    const errorEl        = document.getElementById("context-error");

    const flowMainEl     = document.getElementById("flow-main");
    const flowSubEl      = document.getElementById("flow-sub");
    const liqMainEl      = document.getElementById("liquidity-main");
    const liqSubEl       = document.getElementById("liquidity-sub");

    try {
      if (errorEl) errorEl.textContent = "";

      const res = await fetch(STATE_URL + "?t=" + Date.now(), {
        cache: "no-store"
      });
      if (!res.ok) throw new Error("HTTP " + res.status);
      const state = await res.json();

      const modelPrice   = state.model_price_usd;
      const btcPrice     = typeof state.price_usd === "number" ? state.price_usd : state.spot;
      const priceSource  = state.price_source;
      const signal       = state.signal;
      const message      = state.message;

      const flowBias     = state.flow_bias;
      const flowStrength = state.flow_strength;
      const liqRegime    = state.liquidity_regime;
      const liqStrength  = state.liquidity_strength;

      const prob         = state.signal_probability;
      const horizonHours = state.signal_prob_horizon_hours || 24;

      const marketRegime = state.market_regime; // üî¥ regimul canonic deja calculat

      // Pre»õuri (snapshot)
      if (priceBtcEl) {
        if (Number.isFinite(btcPrice)) {
          priceBtcEl.textContent = USD_FMT.format(btcPrice) + " USD";
        } else {
          priceBtcEl.textContent = "‚Äì";
        }
      }
      if (priceModelEl) {
        if (Number.isFinite(modelPrice)) {
          priceModelEl.textContent = USD_FMT.format(modelPrice) + " USD";
        } else {
          priceModelEl.textContent = "‚Äì";
        }
      }

      // Sursa pre»õului BTC
      if (priceSourceEl) {
        let srcText = "SursƒÉ pre»õ: necunoscutƒÉ";

        if (priceSource === "spot") {
          srcText = "SursƒÉ pre»õ: spot (pia»õƒÉ cash BTC)";
        } else if (priceSource === "model") {
          srcText = "SursƒÉ pre»õ: derivat din modelul intern";
        } else if (typeof priceSource === "string" && priceSource.trim() !== "") {
          srcText = "SursƒÉ pre»õ: " + priceSource;
        }

        priceSourceEl.textContent = srcText;
      }

      // Diferen»õƒÉ + marker
      const diffInfo = buildDiff(modelPrice, btcPrice);
      if (diffMainEl) {
        diffMainEl.textContent = diffInfo.main;
        diffMainEl.className = "diff-text-main " + diffInfo.className;
      }
      if (diffSubEl) diffSubEl.textContent = diffInfo.sub;
      positionMarker(diffInfo.pct, bandTrackEl, bandMarkerEl);

      // Signal ‚Üí headline + chip
      const sigInfo = mapSignal(signal);
      if (signalLabelEl) signalLabelEl.textContent = sigInfo.label;
      if (headlineEl) {
        headlineEl.textContent = sigInfo.headline;
        headlineEl.className = "headline " + sigInfo.className;
      }
      if (signalChip) {
        signalChip.className = "signal-chip " + sigInfo.className;
      }

      // Mesaj
      if (messageEl) {
        messageEl.textContent =
          message ||
          "Nu existƒÉ un mesaj coeziv explicit pentru acest moment. Mecanismul este √Æn modul de observa»õie.";
      }

      // Meta
      if (metaEl) {
        if (typeof prob === "number" && Number.isFinite(prob)) {
          const p = PCT_FMT.format(prob * 100);
          metaEl.innerHTML =
            `Context construit pe baza pozi»õionƒÉrii BTC fa»õƒÉ de nivelul modelului, a Flow Regime »ôi a Liquidity Regime, ` +
            `»õin√¢nd cont de frecven»õa istoricƒÉ a contextelor similare (‚âà ${p}% din cazuri pe ~${horizonHours}h).`;
        } else {
          metaEl.textContent =
            "Context construit pe baza pozi»õionƒÉrii BTC fa»õƒÉ de nivelul modelului, a Flow Regime »ôi a Liquidity Regime, raportate la distribu»õia istoricƒÉ a contextelor similare.";
        }
      }

      // Flow
      const flowInfo = buildFlowText(flowBias, flowStrength);
      if (flowMainEl) flowMainEl.textContent = flowInfo.main;
      if (flowSubEl)  flowSubEl.textContent = flowInfo.sub;

      // Lichiditate
      const liqInfo = buildLiquidityText(liqRegime, liqStrength);
      if (liqMainEl) liqMainEl.textContent = liqInfo.main;
      if (liqSubEl)  liqSubEl.textContent = liqInfo.sub;

      // üî¥ Regim de pia»õƒÉ ‚Äì √Ænt√¢i canonic, apoi fallback
      let regimeId = getRegimeIdFromMarketRegime(marketRegime);
      if (!regimeId) {
        regimeId = determineRegime(diffInfo.pct, flowBias, liqRegime);
      }
      highlightRegime(regimeId);

    } catch (err) {
      console.error(err);
      const errorEl = document.getElementById("context-error");
      if (errorEl) {
        errorEl.textContent =
          "Nu am putut √ÆncƒÉrca contextul mecanismului. VerificƒÉ coeziv_state.json sau workflow-ul de backend.";
      }
      highlightRegime(null);
    }
  }

  // √ÆncƒÉrcare ini»õialƒÉ (snapshot-ul zilei)
  loadState().catch(console.error);
</script>
</body>
</html>
